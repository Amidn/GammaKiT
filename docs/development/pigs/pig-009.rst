.. include:: ../../references.txt

.. _pig-009:

**********************
PIG 9 - Event Sampling
**********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: May 03, 2019
* Accepted: 
* Status: 
* Discussion:  

Abstract
========

An event sampler for gamma events is an important part of the science tools
of the future Cherenkov Telescope Array (CTA) observatory. It will allow users
to simulate sources with different spectral, morphological and temporal properties
and predict the performance of CTA on the simulated data e.g. to support observation
proposals or study the sensitivity of future observations. For this reason, we
propose to implement a framework for event simulation in Gammapy.

The proposed framework consists of individual building blocks, represented by
classes, that can be chained together to achieve a full simulation of an event
list corresponding to a given observation. This includes the simulation of source
events, background events, effects of instrument response functions (IRF) and
arrival times. As underlying method for the actual event sampling we propose to
use inverse CDF sampling (inverseCDF_) with finely binned discrete source,
background, and temporal models.

A working prototype of the proposed method and API can be found in Prototype_ .


Inverse CDF Sampling
====================
Inverse CDF sampling (inverseCDF_) is an established method to sample from discrete
probability mass functions. However it is not the method of choice for other existing
event samplers such as the the Fermi-LAT Science Tools (gtobsim) or CTOOLS (ctobssim).
The latter uses a combination of analytical sampling for models, where a solution
is known (e.g. power-laws) and the rejection sampling method, where the sampling
has to be done numerically (see an example here gammalib_).

As rejection sampling can directly sample from continuous probability density
functions, it is expected to yield very precise results. However an enveloping
distribution is needed, which should be adapted to the target distribution
to be efficient (see also `rejection sampling in Python`_ for an example implementation),
otherwise a lot of computation time is spend in rejecting drawn samples.

For this reason we favour the inverse CDF sampling method, as a simple to implement
and general sampling method.
The precision of the inverse CDF sampling method can be controlled by the resolution
of the input probability mass function (PMF) and is in practice only limited by the
available memory. We will study the required bin-size of the PMFs to reach sufficient
precision. If we find the inverse CDF sampling method to be not precise enough,
it is still possible to achieve better precision with and combination of
analytical and rejection sampling.

The inverse CDF method is also successfully used by `ASTRIsim` (_astrisim), the event
simulator of the AGILE collaboration.


Proposal
========

We propose to introduce the following classes to implement the event sampler framework
in Gammapy.

InverseCDFSampler
-----------------

The first building block of the event sampler is a class that samples from a given 
probability mass function (PMF). The proposed implementation follows closely what
is described here_:


The basic design of the class is as following:

.. code::

    from gammapy.utils.distributions import InverseCDFSampler

    pdf = np.array([])
    cdf_sampler = InverseCDFSampler(pdf=pdf, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class 
implements mainly the `.sample()` method to draw samples from the given pdf:

.. code::

    cdf_sampler = InverseCDFSampler()
    samples = cdf_sampler.sample(size=100)

The returned object is a `np.ndarray` containing the sampled indices.

In addition the `InverseCDFSampler` should have the possibility to sample only 
along a given axis of the PDF. This features is required to handle sampling of 
multiple PDFs at the same time to avoid a Python loop over the PDFs. This will 
be supported by specifying the `axis` argument:

.. code::

    cdf_sampler = InverseCDFSampler(pdf=pdfs, axis=0)
    samples = cdf_sampler.sample(size=1)


The `InverseCDFSampler` could addtionally implement a few helper functions to plot
the CDF and PDF. The `InverseCDFSampler` class will replace the current
`GeneralRandom` and `GeneralRandomArray` classes in `gammapy.utils.distributions`. 



MapEventSampler
---------------

To support sampling from the predicted number of counts maps for source as well 
as background maps, we propose to introduce a `MapEventSampler` class. The 
responsibility of this class is to handle the physical coordinate transformations, 
time dependence of the model, output data structures and sampling of the total 
number of observed events.
Starting from a predicted number of counts map (e.g. computed by the `MapEvaluator`):

.. code::

    src = SkyModel()
    evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
    npred_map = evaluator.compute_npred()

The `MapEventSampler` takes this map and a lightcurve model as an input and 
allows to sample from it with the `.sample()` method:

.. code::

    lightcurve = LightCurveTableModel() # or PhaseCurveTableModel()
    src_sampler = MapEventSampler(npred_map, lightcurve, t_min=, t_max=)

    # draw total number of events
    n_events = src_sampler.npred_total()

    # draw events as an astropy table
    events_src = map_sampler.sample()

If no lightcurve is provided a constant rate can be assumed e.g. for 
background models:

.. code::

    bkg_map = BackgroundModel().map
    bkg_sampler = MapEventSampler(bkg_map, t_min=, t_max=)
    events_bkg = bkg_sample.sample()


The `MapEventSampler` returns an `astropy.table.Table` object, with the following
columns: `TIME`, `RA_TRUE`, `DEC_TRUE`, `ENERGY_TRUE`. Later additional info such
as `DETX` and `DETY` could be added.


IRFEventDistributor
-------------------

We also propose a class to handle correctly the spatially varying IRFs: the
`IRFEventDistibutor` class. Based on the `PSFMap` and `EDispMap`
as an input it interpolates the "correct" IRF at the position of a given event and
applies it. In more detail the class will calculate the psf and the energy dispersion 
for each event true position and true energy. The IRFs are assumed to be constant
and not time-dependent. The time dependency will be handled higher level, by a loop
over good time-intervals (GTIs). The class would be used as following:

.. code::

    events = vstack([events_src_1, events_src_2, ..., events_src_N])
    event_distributor = IRFEventDistributor(psf_map, edisp_map)

    events = irf_distributor.sample_psf(events)
    events = irf_distributor.sample_edisp(events)

Alternatively the IRFs could be applied per model component and be handled in 
the `MapEventSampler`. However in this case the IRFs would not be applied 
correctly for e.g. very extended sources, because the IRF changes over region 
of the source. If we find the approach with the `IRFEventDistibutor` to be not 
performant enough or problematic in memory use, it can be still used as a
simple fallback solution.

The `IRFEventDistributor` adds the following columns to the event table:
`RA`, `DEC` and `ENERGY`.


MapDatasetEventSampler
----------------------

To combine the `MapEventSampler` and `IRFEventDistibutor` objects we finally propose 
to introduce a `MapDatasetEventSampler`, which executes the sampling from all 
source components, applies the IRFs, samples from the background model and 
returns a stacked, combined event list.

This is the proposed high level API:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset, pointing)
    events = dataset_sampler.sample()

This requires to add `t_min` and `t_max` information to `MapDataset` or maybe a 
`MapDataset.gti` attribute, defining the GTI for the given dataset. In addition 
it also requires to add a lightcurve model to the `SkyModel`. Alternatively the
information has to added from the outside:

.. code::

    dataset_sampler = MapDatasetEventSampler(dataset, pointing, t_min, t_max)
    events = dataset_sampler.sample()


The `MapEventSampler` finally returns an `EventList` object and adds the following
columns to the event table: `EVENT_ID` and `MC_ID`. Where `EVENT_ID` is a unique
number to identify the event, while `MC_ID` is a unique ID (number or string) to
identify the model component the event was sampled from.

The `MapDatasetSampler` should also fill the mandatory header information
for event list files decribed on `gamma-astro-data-formats`_.


Simulating multiple observations
================================
The question of the API to simulate multiple observations from e.g. an `ObservationTable`
or `GTI` object as it is needed for simulating data for the CTA data challenge
is not addressed in this PIG. With the `MapDatasetEventSampler` the fundamental
class to simulate events corresponding to a given observation and / or GTI is in
place.


Performance and precision evaluation
====================================
To evaluate the precision and performance of the described framework we propose
to implement a prototype for a simulation / fitting pipeline. Starting from a
selection of spatial, spectral and temporal models, data is simulated and fitted
multiple times to derive distributions and pull-distributions of the reconstructed
model parameters. This pipeline should also monitor the required cpu and memory usage.
This first prototype can be used to evaluate the optimal bin-size (with the best
compromise between performance and precision) for the simulations and to verify
the over-all correctness of the simulated data. Later this prototype can be
developed further into a full simulation / fitting continuous integration system.


Alternatives
============
So far Gammapy only supports binned likelihood analysis and technically most use-
cases for the event sampling could be solved with binned simulations. A binned
simulation can be basically achieved by a call to `numpy.random.poisson()` based
on the predicted number of counts map. This is conceptionally simpler as well as
computationally more efficient then a sampling of event lists. However, to support
the full data access and data reduction process for simulations, event lists are
required. In future Gammapy possibly also supports event based analysis methods
(unbinned likelihood, but also e.g. clustering algorithms), that also require event
lists. For this reason binned simulations cannot present a full equivalent
solution to event sampling.

For the event sampling Gammapy could rely on external tools, such as gammalib
or the IDL based Astri event sampler. As event sampling is a requirement for
CTA science tools and the implementation effort is limited we favor to re-implement
the event sampling in Gammapy. It also serves as a proof of concept of efficient
event sampling in Python.


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, 
ordered by priority:

1. Rename `gammapy.utils.distributions' to `gammapy.utils.random' and move the 
   current `gammapy.utils.random' there (v0.12).
2. Remove the currently unused `GeneralRandomArray` class (v0.12)
3. Implement the InverseCDFSampler in `gammapy.utils.random' in `inverse_cdf.py'
   and add tests.
4. Remove the current `GeneralRandom` class and adapt `gammapy.astro.population.simulate'
   accordingly.
5. Implement the `MapEventSampler` class and corresponding tests in `gammapy.utils.random' (v0.13)
6. Implement `IRFEventDistibutor' class and corresponding tests in `gammapy.utils.random'  (v0.13)
7. Implement `MapDatasetEventSampler' class and test in `gammapy.utils.random' (v0.14)
8. Add tutorial for event simulations of different kinds of sources. (v0.14)


Decision
========


.. _`rejection sampling in Python`: https://wiseodd.github.io/techblog/2015/10/21/rejection-sampling/
.. _Prototype: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb
.. _inverseCDF: https://en.wikipedia.org/wiki/Inverse_transform_sampling
.. _here: https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584
.. _gammalib: http://cta.irap.omp.eu/gammalib/doxygen/GModelSpatialRadialGauss_8cpp_source.html#l00325
.. _spec: https://docs.gammapy.org/0.11/api/gammapy.spectrum.SpectrumSimulation.html
.. _three-D: https://docs.gammapy.org/0.11/notebooks/simulate_3d.html
.. _astrisim: http://www.iasf-milano.inaf.it/~giuliani/astrisim/
.. _gamma-astro-data-formats: https://gamma-astro-data-formats.readthedocs.io/en/latest/events/events.html#mandatory-header-keywords

