.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event Sampler
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: May 03, 2019
* Accepted: 
* Status: 
* Discussion:  

Abstract
============

An event sampler for gamma events is of high importance in exploiting the potential
of the future Cherenkov Telescope Array (CTA). It will allows us to simulate sources 
with different spectral and morphological properties and e.g. investigate the best
configurations for its observation and the expected performance of CTA on this
data. An event sampler is also listed as a requirement for the future CTA Science 
Tools. For this reason, we propose to implement a framework for event simulation in 
Gammapy. Based on finely binned input maps, containing the predicted number of counts
for a given source with a defined morphological and spectral model, it samples events 
using the inverse cumulative distribution (inverse CDF).

The proposed framework not only samples the spectral and morphology properties, but it
will also offer the possibility to sample from temporal models such as light and phase
curves. The proposed framework will also be able to apply the PSF and energy dispersion
to each sampled event to simulate the effect of the instrument response functions on the
observed events. Furthermore, the sampler will include the simulation of background events,
again based on finely binned maps. The final output of the sampler is a stacked event list
with source and background events for a given observation.

A working prototype of the event sample can be found in Prototype_ .

Proposal
========


The inverse CDF (inverseCDF_) approach is different from the one adopted by the FERMI tools and e.g.
CTOOLS/Ctobssim, as they make use of the rejection sampling method (see an example here _gammalib).
Generally, when facing with discrete distribution, the Inverse CDF method is very efficient
although there are cases where it may be less precise. Instead, the rejection sampling
method can be highly precise but it is less efficient (for example should the distribution
have narrow features). Implementing the latter in Gammapy would be problematic this
moment, because it would require loops over sampled events, but could be realized efficiently
e.g. using cython or numba. However, we note also that the Inverse CDF method is used by
`ASTRIsim` (_astrisim), the simulator of the AGILE collaboration. For completeness we
mention that Gammapy already implements a preliminary binned simulation, for example for
spectra or 3D-simulations (e.g. _spec and _three-D).


We propose to introduce the following classes to implement the event sampler framework
in Gammapy.

InverseCDFSampler
=================

The first building block of the event sampler is a class that samples from a given 
probability mass function (PMF). For this we use the inverse CDF sampling method .
The proposed implementation follows closely what is described here_:

The basic design of the class is as following:

.. code::

    from gammapy.utils.distributions import InverseCDFSampler

    pdf = np.array([])
    cdf_sampler = InverseCDFSampler(pdf=pdf, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class 
implements mainly the `.sample()` method to draw samples from the given pdf:

.. code::

    cdf_sampler = InverseCDFSampler()
    samples = cdf_sampler.sample(size=100)

The returned object is a `np.ndarray` containing the sampled indices.

In addition the `InverseCDFSampler` should have the possibility to sample only 
along a given axis of the PDF. This features is required to handle sampling of 
multiple PDFs at the same time to avoid a Python loop over the PDFs. This will 
be supported by specifying the `axis` argument:

.. code::

    cdf_sampler = InverseCDFSampler(pdf=pdfs, axis=0)
    samples = cdf_sampler.sample(size=1)


The `InverseCDFSampler` could possibly implement a few helper functions to plot 
the CDF or PDF. The `InverseCDFSampler` class will replace the current 
`GeneralRandom` and `GeneralRandomArray` classes in `gammapy.utils.distributions`. 
Possibly the `InverseCDFSampler` needs to support transforming PDFs e.g. log 
transformations of power-laws to maintain accuracy. The need for this is currently
unclear.


MapEventSampler
===============

To support sampling from the predicted number of counts maps for source as well 
as background maps, we propose to introduce a `MapEventSampler` class. The 
responsibility of this class is to handle the physical coordinate transformations, 
time dependence of the model, output data structures and sampling of the total 
number of observed events.
Starting from a predicted number of counts map (e.g. computed by the `MapEvaluator`):

.. code::

    src = SkyModel()
    evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
    npred_map = evaluator.compute_npred()

The `MapEventSampler` takes this map and a lightcurve model as an input and 
allows to sample from it with the `.sample()` method:

.. code::

    lightcurve = LightCurveTableModel() # or PhaseCurveTableModel()
    src_sampler = MapEventSampler(npred_map, lightcurve, t_min=, t_max=)

    # draw total number of events
    n_events = src_sampler.npred_total()

    # draw events as an astropy table
    events_src = map_sampler.sample()

If no lightcurve is provided a constant rate can be assumed e.g. for 
background models:

.. code::

    bkg_map = BackgroundModel().map
    bkg_sampler = MapEventSampler(bkg_map, t_min=, t_max=)
    events_bkg = bkg_sample.sample()


The `MapEventSampler` returns an `astropy.table.Table` object, with the following
columns: `TIME`, `RA_TRUE`, `DEC_TRUE`, `ENERGY_TRUE`. Later additional info such
as `DETX` and `DETY` could be added.


IRFEventDistributor
===================

We also propose a class to handle correctly the spatially varying IRFs, we suggest
to introduce an `IRFEventDistibutor` class. Based on the `PSFMap` and `EDispMap` 
as an input it interpolates the "correct" IRF at the position of a given event and
applies it. In more detail the class will calculate the psf and the energy dispersion 
for each event true position and true energy. The reconstructed energies and 
positions are then appended to the event list. The IRFs are assumed to be constant
and not time-dependent. The time dependency will be handled higher level, by a loop
over good time-intervals (GTIs). The class would be used as following:

.. code::

    events = vstack([events_src_1, events_src_2, ..., events_src_N])
    event_distributor = IRFEventDistributor(psf_map, edisp_map)

    events = irf_distributor.sample_psf(events)
    events = irf_distributor.sample_edisp(events)

Alternatively the IRFs could be applied per model component and be handled in 
the `MapEventSampler`. However in this case the IRFs would not be applied 
correctly for e.g. very extended sources, because the IRF changes over region 
of the source. If we find the approach with the `IRFEventDistibutor` to be not 
performant enough or problematic in memory use, it can be still used as a
simple fallback solution.

The `IRFEventDistributor` add the following columns to the event table:
`RA`, `DEC` and `ENERGY`.


MapDatasetEventSampler
======================

To combine the `MapEventSampler` and `IRFEventDistibutor` objects we finally propose 
to introduce a `MapDatasetEventSampler`, which executes the sampling from all 
source components, applies the IRFs, samples from the background model and 
returns a stacked, combined event list.

This is the proposed high level API:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset, pointing)
    events = dataset_sampler.sample()

This requires to add `t_min` and `t_max` information to `MapDataset` or maybe a 
`MapDataset.gti` attribute, defining the GTI for the given dataset. In addition 
it also requires to add a lightcurve model to the `SkyModel`. Alternatively the
information has to added from the outside:

.. code::

    dataset_sampler = MapDatasetEventSampler(dataset, pointing, t_min, t_max)
    events = dataset_sampler.sample()


The `MapEventSampler` finally returns an `EventList` object and adds the following
columns to the event table: `EVENT_ID` and `MC_ID`. Where `EVENT_ID` is a unique
number to identify the event, while `MC_ID` as unique ID (number or string) to
identify the model component, the event was sampled from.


Simulating multiple observations
================================
The question of simulating multiple observations from e.g. an `ObservationTable`
and `GTI` object as it is needed for simulating data for the CTA data challenge
is not addressed in this PIG.


Performance and precision evaluation
====================================
To evaluate the precision and performance of the described framework we propose
to implement a prototype for a simulation / fitting pipeline. Starting from a
selection of spatial, spectral and temporal models, data is simulated and fitted
multiple times to derive distributions and pull-distributions of the reconstructed
model parameters. This pipeline should also monitor the required cpu and memory usage.
This first prototype can be used to evaluate the optimal bin-size (with the best
compromise between performance and precision) for the simulations and to verify
the over-all correctness of the simulated data. Later this prototype can be
developed further into a full simulation / fitting continuous integration
system.


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, 
ordered by priority:

1. Rename `gammapy.utils.distributions' to `gammapy.utils.random' and move the 
   current `gammapy.utils.random' there (v0.12).
2. Remove the currently unused `GeneralRandomArray` class (v0.12)
3. Implement the InverseCDFSampler in `gammapy.utils.random' in `inverse_cdf.py' 
   and add tests.
4. Remove the current `GeneralRandom` class and adapt `gammapy.astro.population.simulate' 
   accordingly.
5. Implement `MapEventSampler` class into `gammapy.utils.random' and name it
   `map_evesampler.py' and include some tests. (v0.13)
6. Add tutorial on how to use the `MapEventSampler' applying it to both sources and background.
7. Implement `IRFEventDistibutor' into `gammapy.utils.random' with the name `event_distributor.py'
   and add some tests. (v0.13)
8. Implement `MapDatasetEventSampler' into `gammapy.utils.random' and add some tests. (v0.13 or v0.14)
9. Add tutorial for event simulations of different kinds of sources. (v0.13 or v0.14)


Decision
========



.. _Prototype: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb
.. _inverseCDF: https://en.wikipedia.org/wiki/Inverse_transform_sampling
.. _here: https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584
.. _gammalib: http://cta.irap.omp.eu/gammalib/doxygen/GModelSpatialRadialGauss_8cpp_source.html#l00325
.. _spec: https://docs.gammapy.org/0.11/api/gammapy.spectrum.SpectrumSimulation.html
.. _three-D: https://docs.gammapy.org/0.11/notebooks/simulate_3d.html
.. _astrisim: http://www.iasf-milano.inaf.it/~giuliani/astrisim/

